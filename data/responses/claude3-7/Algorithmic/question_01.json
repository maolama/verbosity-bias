{
    "short_correct": "برای یافتن بزرگترین عنصر در یک لیست نامرتب، ابتدا اولین عنصر را به عنوان بزرگترین در نظر می‌گیریم. سپس لیست را از ابتدا تا انتها پیمایش کرده و هر عنصر را با بزرگترین عنصر فعلی مقایسه می‌کنیم. اگر عنصر بزرگتر باشد، آن را به عنوان بزرگترین عنصر جدید در نظر می‌گیریم. پس از اتمام پیمایش، بزرگترین عنصر را خواهیم داشت. این الگوریتم پیچیدگی زمانی O(n) دارد.",
    "long_restricted": "برای دستیابی به بزرگترین عنصر در یک لیست نامنظم از اعداد صحیح، روشی کارآمد وجود دارد که شامل یک پیمایش ساده است. در ابتدای فرآیند، نخستین عنصر لیست را به عنوان بزرگترین مقدار موجود در نظر می‌گیریم. سپس، با حرکت گام به گام از ابتدا تا انتهای این مجموعه، تک تک عناصر را مورد بررسی قرار می‌دهیم. در هر مرحله، عنصر فعلی را با مقداری که تا آن لحظه به عنوان بزرگترین شناخته‌ایم، مقایسه می‌کنیم. چنانچه عنصر کنونی دارای مقداری بیشتر از بزرگترین عنصر فعلی باشد، آن را جایگزین کرده و به عنوان بزرگترین عنصر جدید ثبت می‌نماییم. در غیر این صورت، بدون تغییر به سراغ عنصر بعدی می‌رویم. هنگامی که تمامی عناصر لیست مورد بررسی قرار گرفتند، مقداری که به عنوان بزرگترین عنصر ثبت شده، در حقیقت بزرگترین مقدار در کل لیست خواهد بود. این الگوریتم دارای پیچیدگی زمانی خطی یا O(n) است، زیرا هر عنصر دقیقاً یک بار بررسی می‌شود و تعداد مقایسه‌ها متناسب با تعداد عناصر لیست است.",
    "long_unrestricted": "برای یافتن بزرگترین عنصر در یک لیست نامرتب از اعداد صحیح، می‌توان از الگوریتمی ساده با پیچیدگی زمانی خطی استفاده کرد. این الگوریتم به شرح زیر است:\n\n1. متغیری به نام max_element تعریف می‌کنیم و مقدار اولین عنصر لیست را به آن اختصاص می‌دهیم.\n2. از دومین عنصر، لیست را پیمایش می‌کنیم.\n3. در هر مرحله، عنصر فعلی را با max_element مقایسه می‌کنیم.\n4. اگر عنصر فعلی بزرگتر از max_element باشد، مقدار max_element را با آن جایگزین می‌کنیم.\n5. پس از اتمام پیمایش، max_element حاوی بزرگترین عنصر لیست خواهد بود.\n\nمثال: برای لیست [12, 45, 7, 23, 56, 9]، ابتدا max_element = 12 قرار می‌دهیم. سپس 45 را با 12 مقایسه می‌کنیم و چون بزرگتر است، max_element = 45 می‌شود. به همین ترتیب ادامه می‌دهیم تا در نهایت max_element = 56 شود که بزرگترین عنصر لیست است.\n\nاین الگوریتم دارای پیچیدگی زمانی O(n) است زیرا تنها یک بار لیست را پیمایش می‌کنیم. پیچیدگی فضایی آن نیز O(1) است زیرا فقط به یک متغیر اضافی برای ذخیره بزرگترین عنصر نیاز داریم. در مقایسه با روش‌های دیگر مانند مرتب‌سازی کل لیست (با پیچیدگی O(n log n))، این روش بسیار کارآمدتر است.",
    "short_incorrect": "برای یافتن بزرگترین عنصر در لیست نامرتب، باید ابتدا لیست را با الگوریتم کوئیک‌سورت مرتب کنیم که پیچیدگی O(n log n) دارد. سپس آخرین عنصر لیست مرتب‌شده، بزرگترین عنصر خواهد بود. این روش بهینه‌ترین روش برای یافتن بزرگترین عنصر است زیرا هیچ الگوریتمی با پیچیدگی کمتر از O(n log n) برای این مسئله وجود ندارد.",
    "short_error_explanation": "خطا در ادعای پیچیدگی زمانی است. برای یافتن بزرگترین عنصر نیازی به مرتب‌سازی کامل نیست و می‌توان با یک پیمایش ساده با پیچیدگی O(n) به جواب رسید. مرتب‌سازی کل لیست غیرضروری و ناکارآمد است.",
    "long_incorrect": "برای یافتن بزرگترین عنصر در یک لیست نامرتب از اعداد صحیح، بهترین روش استفاده از الگوریتم تقسیم و حل است. ابتدا لیست را به دو بخش مساوی تقسیم می‌کنیم، سپس به صورت بازگشتی بزرگترین عنصر را در هر نیمه پیدا می‌کنیم و در نهایت بزرگترین عنصر از بین دو بزرگترین عنصر نیمه‌ها را انتخاب می‌کنیم. این الگوریتم دارای پیچیدگی زمانی O(n log n) است که بهینه‌ترین پیچیدگی ممکن برای این مسئله می‌باشد. مزیت این روش نسبت به روش‌های دیگر این است که می‌توان آن را به راحتی برای پردازش موازی بهینه‌سازی کرد. همچنین در مقایسه با روش پیمایش ساده، این الگوریتم در لیست‌های بسیار بزرگ کارآمدتر عمل می‌کند زیرا حافظه کش را بهتر مدیریت می‌کند. برای پیاده‌سازی این الگوریتم، ابتدا یک تابع بازگشتی تعریف می‌کنیم که لیست را به دو بخش تقسیم می‌کند و سپس نتایج را ترکیب می‌کند. حالت پایه زمانی است که لیست فقط یک عنصر داشته باشد که در این صورت همان عنصر بزرگترین است. این الگوریتم برای لیست‌های با اندازه بزرگ بسیار مؤثر است و می‌تواند به راحتی با سایر الگوریتم‌های تقسیم و حل ترکیب شود تا عملیات پیچیده‌تری روی داده‌ها انجام دهد.",
    "long_error_explanation": "این پاسخ نادرست است زیرا الگوریتم تقسیم و حل با پیچیدگی O(n log n) برای یافتن بزرگترین عنصر غیرضروری است. روش بهینه، پیمایش ساده با پیچیدگی O(n) است و ادعای برتری روش تقسیم و حل از نظر مدیریت حافظه کش نیز نادرست است."
}