{
    "short_correct": "برای جستجوی یک عدد در لیست مرتب، می‌توان از الگوریتم جستجوی دودویی استفاده کرد. ابتدا عنصر میانی لیست را بررسی می‌کنیم. اگر با عدد مورد نظر برابر بود، پاسخ مثبت است. اگر کوچکتر بود، جستجو را در نیمه راست ادامه می‌دهیم. اگر بزرگتر بود، جستجو را در نیمه چپ ادامه می‌دهیم. این روند را تکرار می‌کنیم تا عدد را پیدا کنیم یا به پایان لیست برسیم. پیچیدگی زمانی O(log n) است.",
    "long_restricted": "برای انجام عملیات جستجو روی یک عدد صحیح در یک لیست مرتب شده، می‌توان از الگوریتم کارآمد جستجوی دودویی بهره گرفت. در این روش ابتدا به بررسی عنصری که در میانه لیست قرار دارد می‌پردازیم. پس از مشاهده این عنصر میانی، چنانچه این مقدار با عدد مورد جستجوی ما یکسان باشد، به نتیجه مثبت رسیده‌ایم و وجود عدد در لیست تأیید می‌شود. در صورتی که عنصر میانی از عدد مورد نظر ما کوچکتر باشد، فرآیند جستجو را تنها در نیمه راست لیست ادامه خواهیم داد، زیرا با توجه به مرتب بودن لیست، تمامی اعداد سمت چپ کوچکتر هستند. از سوی دیگر، اگر عنصر میانی از عدد مورد جستجو بزرگتر باشد، عملیات جستجو را فقط در نیمه چپ لیست پیگیری می‌کنیم. این فرآیند تقسیم و بررسی را به صورت مکرر ادامه می‌دهیم تا زمانی که یا عدد مورد نظر را در لیست بیابیم، یا به این نتیجه برسیم که لیست به پایان رسیده و عدد در آن وجود ندارد. این الگوریتم دارای پیچیدگی زمانی لگاریتمی یا O(log n) می‌باشد که بسیار کارآمدتر از جستجوی خطی است.",
    "long_unrestricted": "برای تعیین وجود یک عدد صحیح x در یک لیست مرتب، بهترین الگوریتم جستجوی دودویی (Binary Search) است. این الگوریتم از ویژگی مرتب بودن لیست بهره می‌برد و به شرح زیر عمل می‌کند:\n\n1. دو شاخص left و right تعریف می‌کنیم که ابتدا و انتهای بازه جستجو را مشخص می‌کنند (ابتدا 0 و n-1).\n2. تا زمانی که left ≤ right باشد، الگوریتم را ادامه می‌دهیم:\n   a. شاخص mid را به عنوان میانه بازه محاسبه می‌کنیم: mid = (left + right) / 2\n   b. اگر لیست[mid] = x باشد، عدد را یافته‌ایم و true برمی‌گردانیم.\n   c. اگر لیست[mid] < x باشد، جستجو را در نیمه راست ادامه می‌دهیم: left = mid + 1\n   d. اگر لیست[mid] > x باشد، جستجو را در نیمه چپ ادامه می‌دهیم: right = mid - 1\n3. اگر از حلقه خارج شویم بدون یافتن x، مقدار false برمی‌گردانیم.\n\nمثال: برای جستجوی عدد 23 در لیست مرتب [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]:\n- ابتدا mid = 4، لیست[4] = 16 (کوچکتر از 23)، پس left = 5 می‌شود\n- سپس mid = 6، لیست[6] = 38 (بزرگتر از 23)، پس right = 5 می‌شود\n- سپس mid = 5، لیست[5] = 23 (برابر با 23)، پس عدد را یافته‌ایم\n\nپیچیدگی زمانی این الگوریتم O(log n) است زیرا در هر مرحله فضای جستجو به نصف کاهش می‌یابد. این بسیار کارآمدتر از جستجوی خطی با پیچیدگی O(n) است.",
    "short_incorrect": "برای جستجوی عدد x در لیست مرتب، می‌توان از الگوریتم جستجوی خطی استفاده کرد. لیست را از ابتدا تا انتها پیمایش کرده و هر عنصر را با x مقایسه می‌کنیم. اگر عنصری برابر با x بود، پاسخ مثبت است، در غیر این صورت x در لیست وجود ندارد. این الگوریتم ساده و مؤثر است و پیچیدگی زمانی آن O(n) می‌باشد.",
    "short_error_explanation": "خطا در انتخاب الگوریتم است. برای لیست مرتب، جستجوی خطی بهینه نیست و باید از جستجوی دودویی با پیچیدگی O(log n) استفاده کرد. استفاده از جستجوی خطی نادیده گرفتن ویژگی مرتب بودن لیست است.",
    "long_incorrect": "برای تعیین وجود عدد x در یک لیست مرتب، می‌توان از الگوریتم جستجوی دودویی اصلاح‌شده استفاده کرد. این الگوریتم با تقسیم لیست به سه بخش مساوی کار می‌کند که بسیار سریع‌تر از جستجوی دودویی معمولی است. ابتدا دو نقطه را در یک سوم و دو سوم لیست انتخاب می‌کنیم. با مقایسه x با این دو نقطه، می‌توانیم تعیین کنیم که x در کدام یک از سه بخش قرار دارد و جستجو را فقط در آن بخش ادامه دهیم. این روش پیچیدگی زمانی O(log₃ n) دارد که از O(log₂ n) جستجوی دودویی معمولی سریع‌تر است. همچنین برای کارایی بیشتر، می‌توانیم از تکنیک پرش بهره ببریم: اگر تعداد عناصر باقیمانده کمتر از یک آستانه مشخص (مثلاً 10 عنصر) باشد، به جستجوی خطی تغییر روش دهیم. این ترکیب باعث می‌شود الگوریتم در عمل حدود 40 درصد سریع‌تر از جستجوی دودویی استاندارد عمل کند، به خصوص در لیست‌های بزرگ که دسترسی به حافظه می‌تواند گلوگاه باشد.",
    "long_error_explanation": "این پاسخ چندین خطا دارد: اول، جستجوی سه‌تایی (ternary search) پیچیدگی بهتری از جستجوی دودویی ندارد و ادعای سرعت بیشتر نادرست است. دوم، ادعای بهبود 40 درصدی با ترکیب روش‌ها بی‌اساس است. سوم، مقایسه O(log₃ n) و O(log₂ n) گمراه‌کننده است زیرا از نظر نمادگذاری بزرگ-O معادل هستند."
}