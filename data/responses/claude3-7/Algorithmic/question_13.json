{
    "short_correct": "برای بررسی مرتب بودن صعودی یک لیست، باید هر عنصر را با عنصر بعدی مقایسه کنیم. از ابتدای لیست شروع می‌کنیم و به ترتیب پیش می‌رویم. اگر در هر مرحله، عنصر فعلی بزرگتر از عنصر بعدی باشد، لیست مرتب نیست. اگر تمام مقایسه‌ها بدون مشکل انجام شود، لیست به ترتیب صعودی مرتب است.",
    "long_restricted": "برای بررسی اینکه آیا یک لیست به ترتیب صعودی مرتب شده است، باید روشی سیستماتیک را دنبال کنیم. این روش شامل مقایسه هر عنصر با عنصر بعدی در لیست است. فرآیند را از ابتدای لیست آغاز می‌کنیم و به صورت ترتیبی به سمت انتها حرکت می‌نماییم. در هر گام، عنصر فعلی را با عنصر بعدی مقایسه می‌کنیم. چنانچه در هر مرحله‌ای از این بررسی، مشاهده کنیم که عنصر فعلی از عنصر بعدی بزرگتر است، می‌توانیم نتیجه بگیریم که لیست مورد نظر به صورت صعودی مرتب نشده است. در چنین حالتی، می‌توانیم بررسی را متوقف کرده و نتیجه منفی را اعلام کنیم. اما اگر تمامی مقایسه‌های انجام شده بدون هیچ مشکل و تناقضی به پایان برسد، یعنی در هیچ موردی عنصر قبلی از عنصر بعدی بزرگتر نباشد، آنگاه می‌توانیم با اطمینان اعلام کنیم که لیست مورد بررسی به ترتیب صعودی مرتب شده است. این روش ساده و کارآمد برای تشخیص مرتب بودن صعودی یک لیست است که با پیمایش یکبار لیست قابل انجام است.",
    "long_unrestricted": "برای بررسی مرتب بودن صعودی یک لیست، چندین روش وجود دارد. ساده‌ترین روش، مقایسه هر عنصر با عنصر بعدی است. ابتدا از اولین عنصر شروع کرده و به ترتیب پیش می‌رویم. اگر در هر مرحله عنصر فعلی بزرگتر از عنصر بعدی باشد، لیست مرتب نیست و می‌توانیم بررسی را متوقف کنیم. در زبان پایتون، می‌توان با یک حلقه for ساده این کار را انجام داد:\n\ndef is_sorted(lst):\n    for i in range(len(lst)-1):\n        if lst[i] > lst[i+1]:\n            return False\n    return True\n\nروش دیگر استفاده از تابع all همراه با درک لیستی است که بسیار مختصر می‌شود:\n\ndef is_sorted(lst):\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))\n\nدر مورد پیچیدگی زمانی، هر دو روش O(n) هستند، زیرا در بدترین حالت باید تمام عناصر لیست را بررسی کنیم. نکته مهم این است که برای لیست‌های خالی یا تک عنصری، پاسخ همیشه مثبت است زیرا هیچ مقایسه‌ای انجام نمی‌شود. همچنین، این روش‌ها برای بررسی مرتب بودن نزولی نیز با تغییر علامت مقایسه قابل استفاده هستند.",
    "short_incorrect": "برای بررسی مرتب بودن صعودی یک لیست، کافی است عنصر اول را با عنصر آخر مقایسه کنیم. اگر عنصر اول کوچکتر از عنصر آخر باشد، لیست به ترتیب صعودی مرتب است. این روش ساده و سریع است و نیازی به بررسی تمام عناصر نیست.",
    "short_error_explanation": "این پاسخ نادرست است زیرا مقایسه فقط عنصر اول و آخر کافی نیست. لیستی مانند [1, 5, 3, 7] با این روش مرتب تشخیص داده می‌شود در حالی که عنصر 5 بزرگتر از 3 است و لیست مرتب نیست.",
    "long_incorrect": "برای بررسی مرتب بودن صعودی یک لیست، روش‌های مختلفی وجود دارد. یکی از بهترین روش‌ها، استفاده از الگوریتم دودویی است. در این روش، لیست را به دو نیمه تقسیم می‌کنیم و هر نیمه را جداگانه بررسی می‌کنیم. سپس چک می‌کنیم که آیا بزرگترین عنصر نیمه اول کوچکتر یا مساوی کوچکترین عنصر نیمه دوم است یا خیر. اگر این شرط برقرار باشد، فرآیند را به صورت بازگشتی برای هر نیمه تکرار می‌کنیم. این روش دارای پیچیدگی زمانی O(log n) است که بسیار سریع‌تر از روش‌های خطی معمول است. برای پیاده‌سازی، ابتدا نقطه میانی را پیدا می‌کنیم، سپس دو نیمه را بررسی کرده و در نهایت شرط مرزی بین دو نیمه را چک می‌کنیم. اگر در هر مرحله شرطی نقض شود، لیست مرتب نیست. این روش برای لیست‌های بزرگ بسیار کارآمد است و نیازی به بررسی تک تک عناصر ندارد. همچنین می‌توان از این روش برای تشخیص لیست‌های نزولی نیز استفاده کرد، فقط کافی است شرط مقایسه را معکوس کنیم. برای لیست‌های خالی یا تک عنصری، پاسخ همیشه مثبت است زیرا چنین لیست‌هایی همیشه مرتب هستند.",
    "long_error_explanation": "این پاسخ نادرست است زیرا الگوریتم بررسی مرتب بودن لیست نمی‌تواند پیچیدگی O(log n) داشته باشد. برای تعیین مرتب بودن، باید حداقل یک بار تمام عناصر را بررسی کنیم که پیچیدگی O(n) دارد. روش تقسیم دودویی برای این مسئله کارایی ندارد."
}