{
    "short_correct": "برای یافتن جفت اعدادی که مجموعشان برابر با k باشد، می‌توانیم از الگوریتم جستجوی دوگانه استفاده کنیم. ابتدا لیست را مرتب می‌کنیم، سپس دو شاخص در ابتدا و انتهای لیست قرار می‌دهیم. در هر مرحله مجموع دو عدد را بررسی می‌کنیم: اگر مجموع کمتر از k باشد، شاخص ابتدایی را افزایش می‌دهیم؛ اگر بیشتر از k باشد، شاخص انتهایی را کاهش می‌دهیم؛ و اگر برابر k باشد، جفت مورد نظر را یافته‌ایم. پیچیدگی زمانی O(n log n) است.",
    "long_restricted": "به منظور پیدا کردن جفت اعدادی که مجموعشان دقیقاً برابر با عدد k باشد، می‌توانیم از روش جستجوی دوگانه بهره ببریم. در گام نخست، باید لیست اعداد صحیح را به صورت صعودی مرتب‌سازی نماییم. پس از مرتب‌سازی، دو شاخص تعریف می‌کنیم؛ یک شاخص در ابتدای لیست مرتب‌شده (شاخص چپ) و شاخص دیگر در انتهای لیست (شاخص راست). در ادامه، در هر مرحله مجموع دو عدد مشخص شده توسط این شاخص‌ها را محاسبه و با عدد k مقایسه می‌کنیم. چنانچه مجموع محاسبه شده کمتر از k باشد، شاخص چپ را یک واحد افزایش می‌دهیم تا عدد بزرگتری را در نظر بگیریم. در صورتی که مجموع محاسبه شده بیشتر از k باشد، شاخص راست را یک واحد کاهش می‌دهیم تا عدد کوچکتری را انتخاب کنیم. در نهایت، اگر مجموع دو عدد دقیقاً برابر با k شود، به معنای یافتن جفت مورد نظر است و می‌توانیم این دو عدد را به عنوان پاسخ برگردانیم. این فرآیند را تا زمانی ادامه می‌دهیم که یا جفت مورد نظر را بیابیم یا شاخص‌ها از یکدیگر عبور کنند، که در این حالت نتیجه می‌گیریم چنین جفتی وجود ندارد. از نظر پیچیدگی زمانی، با توجه به مرتب‌سازی اولیه که O(n log n) زمان می‌برد و سپس یک پیمایش خطی که O(n) است، پیچیدگی کلی الگوریتم O(n log n) خواهد بود.",
    "long_unrestricted": "برای یافتن جفت اعدادی که مجموعشان برابر با k باشد، چندین الگوریتم می‌توان پیشنهاد داد. روش اول و ساده‌ترین راه، استفاده از دو حلقه تودرتو است که تمام جفت‌های ممکن را بررسی می‌کند. این روش پیچیدگی زمانی O(n²) دارد که برای لیست‌های بزرگ کارآمد نیست. روش دوم و بهینه‌تر، استفاده از جستجوی دوگانه (Two Pointer) است. در این روش، ابتدا لیست را مرتب می‌کنیم (با پیچیدگی O(n log n))، سپس دو شاخص در ابتدا و انتهای لیست قرار می‌دهیم. در هر مرحله، مجموع دو عدد مشخص شده توسط شاخص‌ها را با k مقایسه می‌کنیم: اگر مجموع کمتر از k باشد، شاخص ابتدایی را افزایش می‌دهیم تا به عدد بزرگتری برسیم؛ اگر مجموع بیشتر از k باشد، شاخص انتهایی را کاهش می‌دهیم تا به عدد کوچکتری برسیم؛ و اگر مجموع دقیقاً برابر k باشد، جفت مورد نظر را یافته‌ایم. پیچیدگی زمانی این روش O(n log n) است. روش سوم، استفاده از جدول هش (Hash Table) است. در این روش، لیست را یک بار پیمایش می‌کنیم و برای هر عدد a، بررسی می‌کنیم آیا k-a در جدول هش وجود دارد یا خیر. اگر وجود داشت، جفت (a, k-a) را به عنوان پاسخ برمی‌گردانیم؛ در غیر این صورت، a را به جدول هش اضافه می‌کنیم. پیچیدگی زمانی این روش O(n) است که بهینه‌ترین حالت ممکن است. البته این روش به حافظه بیشتری نیاز دارد. انتخاب بین روش دوم و سوم بستگی به محدودیت‌های مسئله دارد؛ اگر حافظه محدود باشد، روش دوم مناسب‌تر است، اما اگر سرعت اهمیت بیشتری داشته باشد، روش سوم بهتر است.",
    "short_incorrect": "برای یافتن جفت اعدادی که مجموعشان برابر با k باشد، می‌توانیم لیست را مرتب کرده و سپس برای هر عدد a در لیست، عدد k-a را با جستجوی دودویی در لیست جستجو کنیم. اگر k-a یافت شود، جفت (a, k-a) را برمی‌گردانیم. این الگوریتم پیچیدگی زمانی O(n) دارد و برای لیست‌های بزرگ بسیار کارآمد است.",
    "short_error_explanation": "پیچیدگی زمانی الگوریتم ذکر شده O(n log n) است، نه O(n). زیرا مرتب‌سازی O(n log n) زمان می‌برد و برای هر عنصر، یک جستجوی دودویی O(log n) انجام می‌شود، که در مجموع O(n log n) می‌شود.",
    "long_incorrect": "برای یافتن جفت اعدادی که مجموعشان برابر با k باشد، می‌توانیم از چند الگوریتم استفاده کنیم. روش اول استفاده از جدول هش است. در این روش، لیست را یک بار پیمایش می‌کنیم و برای هر عدد a، بررسی می‌کنیم آیا k-a در جدول هش وجود دارد یا خیر. اگر وجود داشت، جفت (a, k-a) را به عنوان پاسخ برمی‌گردانیم؛ در غیر این صورت، a را به جدول هش اضافه می‌کنیم. پیچیدگی زمانی این روش O(n) است. روش دوم استفاده از جستجوی دوگانه است. در این روش، ابتدا لیست را مرتب می‌کنیم، سپس دو شاخص در ابتدا و انتهای لیست قرار می‌دهیم. در هر مرحله مجموع دو عدد را با k مقایسه می‌کنیم: اگر مجموع کمتر از k باشد، شاخص ابتدایی را افزایش می‌دهیم؛ اگر بیشتر از k باشد، شاخص انتهایی را کاهش می‌دهیم؛ و اگر برابر k باشد، جفت مورد نظر را یافته‌ایم. پیچیدگی زمانی این روش O(n log n) است به دلیل مرتب‌سازی اولیه. روش سوم استفاده از دو حلقه تودرتو است که تمام جفت‌های ممکن را بررسی می‌کند. این روش پیچیدگی زمانی O(n²) دارد. نکته مهم این است که اگر لیست از قبل مرتب شده باشد، روش جستجوی دوگانه پیچیدگی O(n) خواهد داشت که سریع‌ترین روش ممکن است. همچنین، اگر بخواهیم تمام جفت‌های ممکن را پیدا کنیم نه فقط یکی از آنها، باید الگوریتم را کمی تغییر دهیم تا پس از یافتن هر جفت، به جستجو ادامه دهد.",
    "long_error_explanation": "در روش جستجوی دوگانه، حتی اگر لیست از قبل مرتب شده باشد، پیچیدگی زمانی همچنان O(n) است، نه O(log n) که در متن ادعا شده. همچنین، در روش جدول هش، باید ابتدا جدول را خالی کرد و سپس عناصر را یک به یک بررسی کرد."
}