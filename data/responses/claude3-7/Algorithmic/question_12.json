{
    "short_correct": "برای پیدا کردن دومین کوچکترین عنصر در لیست اعداد صحیح، چند روش وجود دارد: ۱) مرتب‌سازی لیست و انتخاب عنصر با شاخص ۱؛ ۲) پیمایش لیست و نگهداری دو متغیر برای کوچکترین و دومین کوچکترین عنصر؛ ۳) یافتن کوچکترین عنصر، سپس پیمایش مجدد لیست برای یافتن کوچکترین عنصری که با اولین مورد متفاوت است؛ ۴) استفاده از ساختار داده‌های پیشرفته مانند صف اولویت.",
    "long_restricted": "برای یافتن دومین کوچکترین عنصر در یک لیست از اعداد صحیح، روش‌های متنوعی وجود دارد که می‌توان از آنها بهره برد. یکی از ساده‌ترین این روش‌ها، مرتب‌سازی کامل لیست و سپس انتخاب عنصری است که در موقعیت شاخص ۱ (دومین موقعیت) قرار می‌گیرد. روش دیگری که می‌توان به کار گرفت، پیمایش یک‌باره لیست و نگهداری همزمان دو متغیر جداگانه است که یکی برای ذخیره‌سازی کوچکترین عنصر و دیگری برای ثبت دومین کوچکترین عنصر مورد استفاده قرار می‌گیرد. رویکرد سومی که می‌توان اتخاذ نمود، شامل دو مرحله پیمایش لیست است: ابتدا لیست را برای یافتن کوچکترین عنصر پیمایش می‌کنیم، سپس در پیمایش دوم، به دنبال کوچکترین عنصری می‌گردیم که با عنصر کوچکترین یافته شده در مرحله اول، تفاوت داشته باشد. علاوه بر این روش‌ها، می‌توان از ساختارهای داده پیشرفته‌تری همچون صف اولویت بهره برد که امکان دسترسی و استخراج عناصر را بر اساس اولویت (در اینجا کوچکی) فراهم می‌آورد. با استفاده از این ساختار داده، می‌توانیم پس از قرار دادن تمامی عناصر لیست در صف اولویت، کوچکترین عنصر را استخراج کرده و سپس دومین کوچکترین عنصر را نیز به همین ترتیب بدست آوریم.",
    "long_unrestricted": "برای یافتن دومین کوچکترین عنصر در یک لیست اعداد صحیح، چندین الگوریتم با کارایی‌های مختلف وجود دارد:\n\n1. روش مرتب‌سازی: ساده‌ترین روش، مرتب‌سازی کل لیست و انتخاب عنصر دوم است. با استفاده از الگوریتم‌های مرتب‌سازی کارآمد مانند Quicksort یا Mergesort، پیچیدگی زمانی O(n log n) خواهد بود. مثال در پایتون: `sorted_list = sorted(nums); second_min = sorted_list[1]`.\n\n2. روش پیمایش دوگانه: ابتدا لیست را برای یافتن کوچکترین عنصر پیمایش می‌کنیم، سپس دوباره برای یافتن کوچکترین عنصری که با اولی متفاوت است پیمایش می‌کنیم. این روش دارای پیچیدگی زمانی O(2n) یا همان O(n) است، اما نیاز به دو بار پیمایش دارد.\n\n3. روش پیمایش یک‌باره: می‌توانیم با یک بار پیمایش لیست و نگهداری دو متغیر برای کوچکترین و دومین کوچکترین عنصر، این مسئله را حل کنیم. هر عنصر جدید را با این دو مقدار مقایسه کرده و در صورت نیاز آنها را به‌روزرسانی می‌کنیم. این روش دارای پیچیدگی زمانی O(n) و فضایی O(1) است.\n\n4. استفاده از ساختار داده‌های پیشرفته: می‌توانیم از صف اولویت (Min-Heap) استفاده کنیم. ابتدا تمام عناصر را وارد صف کرده، سپس کوچکترین عنصر را استخراج می‌کنیم و در نهایت دومین کوچکترین را برمی‌داریم. پیچیدگی زمانی این روش O(n + 2 log n) است.\n\n5. الگوریتم انتخاب: می‌توانیم از الگوریتم انتخاب (Selection Algorithm) برای یافتن عنصر با رتبه دوم استفاده کنیم که در بهترین حالت پیچیدگی زمانی O(n) دارد.\n\nباید توجه داشت که در صورت وجود المان‌های تکراری، ممکن است نیاز به تعریف دقیق‌تری از «دومین کوچکترین» داشته باشیم - آیا منظور دومین عنصر از نظر مقدار است یا دومین مقدار منحصربه‌فرد؟",
    "short_incorrect": "برای یافتن دومین کوچکترین عنصر در لیست اعداد صحیح، بهترین روش استفاده از الگوریتم Quick Select است. این الگوریتم همیشه در زمان O(log n) اجرا می‌شود و نیازی به مرتب‌سازی کل لیست ندارد. کافیست محور (pivot) را انتخاب کرده و لیست را به دو بخش تقسیم کنیم تا سریعاً به جواب برسیم.",
    "short_error_explanation": "الگوریتم Quick Select پیچیدگی زمانی O(n) در حالت متوسط و O(n²) در بدترین حالت دارد، نه O(log n). همچنین این الگوریتم برای یافتن عنصر k-ام است و پیاده‌سازی آن برای یافتن دومین کوچکترین عنصر به سادگی توصیف شده نیست.",
    "long_incorrect": "برای یافتن دومین کوچکترین عنصر در لیست اعداد صحیح، می‌توانیم از چندین روش استفاده کنیم. یکی از بهترین روش‌ها استفاده از درخت دودویی متوازن است که می‌تواند این عملیات را در زمان O(log log n) انجام دهد. ابتدا همه عناصر را در درخت قرار می‌دهیم و سپس با استفاده از پیمایش inorder، دومین عنصر را استخراج می‌کنیم. روش دیگر استفاده از الگوریتم Quick Select است که همیشه در زمان O(log n) اجرا می‌شود و بسیار کارآمدتر از مرتب‌سازی کل لیست است. همچنین می‌توانیم از الگوریتم‌های تصادفی استفاده کنیم که در زمان تقریبی O(n/2) کار می‌کنند زیرا به طور میانگین فقط نیمی از لیست را بررسی می‌کنند. یک روش ساده دیگر، استفاده از دو متغیر برای نگهداری کوچکترین و دومین کوچکترین عنصر است، اما این روش در مواردی که اعداد تکراری وجود دارند، دچار مشکل می‌شود و نیاز به بررسی‌های اضافی دارد که پیچیدگی را به O(n log n) افزایش می‌دهد. روش دیگر، استفاده از الگوریتم Fibonacci Heap است که می‌تواند عملیات استخراج مینیمم را در زمان O(1) انجام دهد و برای یافتن دومین کوچکترین عنصر بسیار مناسب است.",
    "long_error_explanation": "هیچ الگوریتمی برای یافتن دومین کوچکترین عنصر در زمان O(log log n) یا O(log n) وجود ندارد. Quick Select پیچیدگی O(n) دارد و الگوریتم‌های تصادفی زمان O(n/2) ندارند. همچنین پیمایش لیست با دو متغیر در حضور اعداد تکراری به O(n log n) افزایش نمی‌یابد."
}