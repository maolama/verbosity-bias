{
    "short_correct": "برای معکوس کردن ترتیب آیتم‌های یک مجموعه بدون استفاده از تابع آماده، می‌توانیم از یک لیست جدید استفاده کنیم و آیتم‌ها را از انتها به ابتدا در آن قرار دهیم. روش دیگر استفاده از الگوریتم جابجایی درجا است که دو شاخص در ابتدا و انتهای لیست تعریف کرده و مقادیر آن‌ها را با هم جابجا می‌کنیم، سپس شاخص‌ها را به سمت مرکز لیست حرکت می‌دهیم تا زمانی که به هم برسند یا از هم عبور کنند.",
    "long_restricted": "برای انجام فرایند معکوس‌سازی ترتیب آیتم‌های یک مجموعه بدون بهره‌گیری از توابع آماده معکوس‌کننده، می‌توانیم از دو روش اصلی استفاده نماییم. در روش نخست، یک لیست خالی جدید ایجاد می‌کنیم و تمامی عناصر مجموعه اصلی را از انتها به سمت ابتدا در این لیست جدید قرار می‌دهیم. به این ترتیب، ترتیب معکوس آیتم‌ها در لیست جدید شکل می‌گیرد. روش دوم که کارآمدتر است، استفاده از الگوریتم جابجایی درجا می‌باشد. در این روش، دو شاخص تعریف می‌کنیم؛ یکی در ابتدای لیست و دیگری در انتهای آن. سپس مقادیر این دو شاخص را با یکدیگر تعویض می‌نماییم و پس از هر تعویض، شاخص ابتدایی را یک واحد به جلو و شاخص انتهایی را یک واحد به عقب حرکت می‌دهیم. این فرایند جابجایی را تا زمانی ادامه می‌دهیم که دو شاخص به یکدیگر برسند یا از یکدیگر عبور کنند. در این نقطه، تمامی عناصر لیست به صورت معکوس مرتب شده‌اند و فرایند معکوس‌سازی به اتمام می‌رسد. این روش بدون نیاز به حافظه اضافی قابل انجام است و کارایی بالایی دارد.",
    "long_unrestricted": "برای معکوس کردن ترتیب آیتم‌های یک مجموعه بدون استفاده از توابع آماده معکوس‌کننده، می‌توانیم از چندین روش استفاده کنیم. روش اول، ساخت یک لیست جدید و پر کردن آن به صورت معکوس است. در این روش، یک لیست خالی ایجاد می‌کنیم و با پیمایش لیست اصلی از انتها به ابتدا، هر عنصر را به لیست جدید اضافه می‌کنیم. برای مثال، اگر لیست اصلی [علی، محمد، سارا، مریم] باشد، با پیمایش از انتها، لیست جدید به صورت [مریم، سارا، محمد، علی] خواهد بود. روش دوم، استفاده از الگوریتم جابجایی درجا است که بهینه‌تر است زیرا به حافظه اضافی نیاز ندارد. در این روش، دو شاخص تعریف می‌کنیم: یکی در ابتدا (i=0) و دیگری در انتها (j=n-1). سپس مقادیر این دو شاخص را با هم جابجا کرده، i را یک واحد افزایش و j را یک واحد کاهش می‌دهیم. این فرایند تا زمانی که i<j باشد ادامه می‌یابد. در زبان پایتون، کد این الگوریتم به شکل زیر خواهد بود:\n\n```python\ndef reverse_list(lst):\n    i = 0\n    j = len(lst) - 1\n    while i < j:\n        lst[i], lst[j] = lst[j], lst[i]\n        i += 1\n        j -= 1\n    return lst\n```\n\nروش سوم، استفاده از بازگشت (recursion) است. در این روش، ابتدا عنصر اول و آخر را جابجا کرده، سپس تابع را برای زیرلیست باقیمانده (بدون عنصر اول و آخر) فراخوانی می‌کنیم. این فرایند تا زمانی که لیست خالی یا تک عنصری شود ادامه می‌یابد. هر کدام از این روش‌ها مزایا و معایب خود را دارند، اما روش جابجایی درجا معمولاً بهترین انتخاب از نظر کارایی و استفاده از حافظه است.",
    "short_incorrect": "برای معکوس کردن ترتیب آیتم‌ها در یک مجموعه بدون استفاده از تابع آماده، می‌توانیم از یک حلقه استفاده کنیم که از ابتدا تا انتهای لیست حرکت می‌کند و هر عنصر را با عنصر متناظر آن از انتها جابجا می‌کند. این فرایند n/2 بار تکرار می‌شود، که n تعداد کل عناصر است. پیچیدگی زمانی این الگوریتم O(log n) خواهد بود.",
    "short_error_explanation": "پیچیدگی زمانی الگوریتم معکوس‌سازی با روش جابجایی درجا O(n) است، نه O(log n). زیرا باید تقریباً نیمی از عناصر را جابجا کنیم و تعداد این عملیات متناسب با تعداد کل عناصر است.",
    "long_incorrect": "برای معکوس کردن ترتیب آیتم‌های یک مجموعه بدون استفاده از توابع آماده معکوس‌کننده، می‌توانیم از چندین روش بهره ببریم. روش اول و ساده‌ترین راه، استفاده از یک لیست جدید است. در این روش، یک لیست خالی ایجاد می‌کنیم و با پیمایش لیست اصلی از ابتدا به انتها، هر عنصر را در ابتدای لیست جدید اضافه می‌کنیم. به این ترتیب، ترتیب عناصر به صورت خودکار معکوس خواهد شد. روش دوم که بهینه‌تر است، استفاده از الگوریتم جابجایی درجا است. در این روش، دو شاخص تعریف می‌کنیم: یکی در ابتدا (i=0) و دیگری در انتها (j=n-1). سپس مقادیر این دو شاخص را با هم جابجا کرده، i را یک واحد افزایش و j را یک واحد کاهش می‌دهیم. این فرایند تا زمانی که i>=j باشد ادامه می‌یابد. از آنجا که در هر تکرار حلقه دو عنصر را بررسی می‌کنیم، پیچیدگی زمانی این الگوریتم O(n/2) یا به سادگی O(n) خواهد بود. روش سوم، استفاده از یک پشته (stack) است. در این روش، ابتدا تمام عناصر لیست را در یک پشته قرار می‌دهیم، سپس با خالی کردن پشته، عناصر را به ترتیب در لیست جدید قرار می‌دهیم. به دلیل ماهیت پشته که به صورت LIFO (آخرین ورودی، اولین خروجی) عمل می‌کند، ترتیب عناصر به طور طبیعی معکوس خواهد شد. این روش نیز پیچیدگی زمانی O(n) دارد اما به حافظه اضافی نیاز دارد.",
    "long_error_explanation": "در روش جابجایی درجا، شرط توقف حلقه باید i<j باشد نه i>=j. همچنین، در روش اول، اگر عناصر را از ابتدا به انتهای لیست اصلی پیمایش کرده و در ابتدای لیست جدید اضافه کنیم، عملیات درج در ابتدای لیست ناکارآمد است و پیچیدگی را افزایش می‌دهد."
}